<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/swagger/src/main/java/com/nicenpc/swagger/YamlFilter.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/swagger/src/main/java/com/nicenpc/swagger/YamlFilter.java" />
              <option name="originalContent" value="package com.nicenpc.swagger;&#10;&#10;import org.yaml.snakeyaml.DumperOptions;&#10;import org.yaml.snakeyaml.LoaderOptions;&#10;import org.yaml.snakeyaml.Yaml;&#10;&#10;import java.io.FileInputStream;&#10;import java.io.FileNotFoundException;&#10;import java.io.InputStream;&#10;import java.util.LinkedHashMap;&#10;import java.util.Map;&#10;&#10;public class YamlFilter {&#10;&#10;    private final Map&lt;String, Object&gt; data;&#10;&#10;    public YamlFilter(String yamlFilePath) throws FileNotFoundException {&#10;        InputStream inputStream = new FileInputStream(yamlFilePath);&#10;        LoaderOptions options = new LoaderOptions();&#10;        options.setCodePointLimit(20 * 1024 * 1024); // 10MB&#10;        Yaml yaml = new Yaml(options);&#10;        this.data = yaml.load(inputStream);&#10;    }&#10;&#10;    public Map&lt;String, Object&gt; filterByApi(String apiPath, String httpMethod) {&#10;        if (data == null || !data.containsKey(&quot;paths&quot;)) {&#10;            return null;&#10;        }&#10;&#10;        Map&lt;String, Object&gt; paths = (Map&lt;String, Object&gt;) data.get(&quot;paths&quot;);&#10;        if (!paths.containsKey(apiPath)) {&#10;            return null;&#10;        }&#10;&#10;        Map&lt;String, Object&gt; pathItem = (Map&lt;String, Object&gt;) paths.get(apiPath);&#10;        String methodKey = httpMethod.toLowerCase();&#10;        if (!pathItem.containsKey(methodKey)) {&#10;            return null;&#10;        }&#10;&#10;        Object operation = pathItem.get(methodKey);&#10;&#10;        // 建立新的過濾後的資料結構&#10;        Map&lt;String, Object&gt; filteredData = new LinkedHashMap&lt;&gt;();&#10;        // 複製 metadata&#10;        filteredData.put(&quot;openapi&quot;, data.get(&quot;openapi&quot;));&#10;        filteredData.put(&quot;info&quot;, data.get(&quot;info&quot;));&#10;        if (data.containsKey(&quot;servers&quot;)) {&#10;            filteredData.put(&quot;servers&quot;, data.get(&quot;servers&quot;));&#10;        }&#10;        if (data.containsKey(&quot;components&quot;)) {&#10;            filteredData.put(&quot;components&quot;, data.get(&quot;components&quot;)); // 為了確保 $ref 能正常運作，保留所有 components&#10;        }&#10;&#10;&#10;        // 建立只包含指定 API 的 paths&#10;        Map&lt;String, Object&gt; newPathItem = new LinkedHashMap&lt;&gt;();&#10;        newPathItem.put(methodKey, operation);&#10;&#10;        Map&lt;String, Object&gt; newPaths = new LinkedHashMap&lt;&gt;();&#10;        newPaths.put(apiPath, newPathItem);&#10;&#10;        filteredData.put(&quot;paths&quot;, newPaths);&#10;&#10;        return filteredData;&#10;    }&#10;&#10;    /**&#10;     * 根據多個 API 路徑與方法過濾，產生新的 YAML 結構&#10;     * @param apiMethods 欲保留的 API 路徑與方法，格式為 Map&lt;apiPath, List&lt;httpMethod&gt;&gt;&#10;     * @return 過濾後的 YAML 結構&#10;     */&#10;    public Map&lt;String, Object&gt; filterByApis(Map&lt;String, java.util.List&lt;String&gt;&gt; apiMethods) {&#10;        if (data == null || !data.containsKey(&quot;paths&quot;)) {&#10;            return null;&#10;        }&#10;&#10;        Map&lt;String, Object&gt; paths = (Map&lt;String, Object&gt;) data.get(&quot;paths&quot;);&#10;        Map&lt;String, Object&gt; newPaths = new LinkedHashMap&lt;&gt;();&#10;&#10;        for (Map.Entry&lt;String, java.util.List&lt;String&gt;&gt; entry : apiMethods.entrySet()) {&#10;            String apiPath = entry.getKey();&#10;            if (!paths.containsKey(apiPath)) continue;&#10;            Map&lt;String, Object&gt; pathItem = (Map&lt;String, Object&gt;) paths.get(apiPath);&#10;&#10;            Map&lt;String, Object&gt; newPathItem = new LinkedHashMap&lt;&gt;();&#10;            for (String method : entry.getValue()) {&#10;                String methodKey = method.toLowerCase();&#10;                if (pathItem.containsKey(methodKey)) {&#10;                    newPathItem.put(methodKey, pathItem.get(methodKey));&#10;                }&#10;            }&#10;            if (!newPathItem.isEmpty()) {&#10;                newPaths.put(apiPath, newPathItem);&#10;            }&#10;        }&#10;&#10;        if (newPaths.isEmpty()) return null;&#10;&#10;        Map&lt;String, Object&gt; filteredData = new LinkedHashMap&lt;&gt;();&#10;        filteredData.put(&quot;openapi&quot;, data.get(&quot;openapi&quot;));&#10;        filteredData.put(&quot;info&quot;, data.get(&quot;info&quot;));&#10;        if (data.containsKey(&quot;servers&quot;)) {&#10;            filteredData.put(&quot;servers&quot;, data.get(&quot;servers&quot;));&#10;        }&#10;        if (data.containsKey(&quot;components&quot;)) {&#10;            filteredData.put(&quot;components&quot;, data.get(&quot;components&quot;));&#10;        }&#10;        filteredData.put(&quot;paths&quot;, newPaths);&#10;&#10;        return filteredData;&#10;    }&#10;&#10;    public String toYaml(Map&lt;String, Object&gt; filteredData) {&#10;        if (filteredData == null) {&#10;            return &quot;&quot;;&#10;        }&#10;        DumperOptions options = new DumperOptions();&#10;        options.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);&#10;        options.setPrettyFlow(true);&#10;        options.setIndent(2);&#10;&#10;        Yaml yaml = new Yaml(options);&#10;        return yaml.dump(filteredData);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.nicenpc.swagger;&#10;&#10;import org.yaml.snakeyaml.DumperOptions;&#10;import org.yaml.snakeyaml.LoaderOptions;&#10;import org.yaml.snakeyaml.Yaml;&#10;&#10;import java.io.FileInputStream;&#10;import java.io.FileNotFoundException;&#10;import java.io.FileWriter;&#10;import java.io.IOException;&#10;import java.io.InputStream;&#10;import java.util.LinkedHashMap;&#10;import java.util.Map;&#10;&#10;public class YamlFilter {&#10;&#10;    private final Map&lt;String, Object&gt; data;&#10;&#10;    public YamlFilter(String yamlFilePath) throws FileNotFoundException {&#10;        InputStream inputStream = new FileInputStream(yamlFilePath);&#10;        LoaderOptions options = new LoaderOptions();&#10;        options.setCodePointLimit(20 * 1024 * 1024); // 10MB&#10;        Yaml yaml = new Yaml(options);&#10;        this.data = yaml.load(inputStream);&#10;    }&#10;&#10;    public Map&lt;String, Object&gt; filterByApi(String apiPath, String httpMethod) {&#10;        if (data == null || !data.containsKey(&quot;paths&quot;)) {&#10;            return null;&#10;        }&#10;&#10;        Map&lt;String, Object&gt; paths = (Map&lt;String, Object&gt;) data.get(&quot;paths&quot;);&#10;        if (!paths.containsKey(apiPath)) {&#10;            return null;&#10;        }&#10;&#10;        Map&lt;String, Object&gt; pathItem = (Map&lt;String, Object&gt;) paths.get(apiPath);&#10;        String methodKey = httpMethod.toLowerCase();&#10;        if (!pathItem.containsKey(methodKey)) {&#10;            return null;&#10;        }&#10;&#10;        Object operation = pathItem.get(methodKey);&#10;&#10;        // 建立新的過濾後的資料結構&#10;        Map&lt;String, Object&gt; filteredData = new LinkedHashMap&lt;&gt;();&#10;        // 複製 metadata&#10;        filteredData.put(&quot;openapi&quot;, data.get(&quot;openapi&quot;));&#10;        filteredData.put(&quot;info&quot;, data.get(&quot;info&quot;));&#10;        if (data.containsKey(&quot;servers&quot;)) {&#10;            filteredData.put(&quot;servers&quot;, data.get(&quot;servers&quot;));&#10;        }&#10;        if (data.containsKey(&quot;components&quot;)) {&#10;            filteredData.put(&quot;components&quot;, data.get(&quot;components&quot;)); // 為了確保 $ref 能正常運作，保留所有 components&#10;        }&#10;&#10;&#10;        // 建立只包含指定 API 的 paths&#10;        Map&lt;String, Object&gt; newPathItem = new LinkedHashMap&lt;&gt;();&#10;        newPathItem.put(methodKey, operation);&#10;&#10;        Map&lt;String, Object&gt; newPaths = new LinkedHashMap&lt;&gt;();&#10;        newPaths.put(apiPath, newPathItem);&#10;&#10;        filteredData.put(&quot;paths&quot;, newPaths);&#10;&#10;        return filteredData;&#10;    }&#10;&#10;    /**&#10;     * 根據多個 API 路徑與方法過濾，產生新的 YAML 結構&#10;     * @param apiMethods 欲保留的 API 路徑與方法，格式為 Map&lt;apiPath, List&lt;httpMethod&gt;&gt;&#10;     * @return 過濾後的 YAML 結構&#10;     */&#10;    public Map&lt;String, Object&gt; filterByApis(Map&lt;String, java.util.List&lt;String&gt;&gt; apiMethods) {&#10;        if (data == null || !data.containsKey(&quot;paths&quot;)) {&#10;            return null;&#10;        }&#10;&#10;        Map&lt;String, Object&gt; paths = (Map&lt;String, Object&gt;) data.get(&quot;paths&quot;);&#10;        Map&lt;String, Object&gt; newPaths = new LinkedHashMap&lt;&gt;();&#10;&#10;        for (Map.Entry&lt;String, java.util.List&lt;String&gt;&gt; entry : apiMethods.entrySet()) {&#10;            String apiPath = entry.getKey();&#10;            if (!paths.containsKey(apiPath)) continue;&#10;            Map&lt;String, Object&gt; pathItem = (Map&lt;String, Object&gt;) paths.get(apiPath);&#10;&#10;            Map&lt;String, Object&gt; newPathItem = new LinkedHashMap&lt;&gt;();&#10;            for (String method : entry.getValue()) {&#10;                String methodKey = method.toLowerCase();&#10;                if (pathItem.containsKey(methodKey)) {&#10;                    newPathItem.put(methodKey, pathItem.get(methodKey));&#10;                }&#10;            }&#10;            if (!newPathItem.isEmpty()) {&#10;                newPaths.put(apiPath, newPathItem);&#10;            }&#10;        }&#10;&#10;        if (newPaths.isEmpty()) return null;&#10;&#10;        Map&lt;String, Object&gt; filteredData = new LinkedHashMap&lt;&gt;();&#10;        filteredData.put(&quot;openapi&quot;, data.get(&quot;openapi&quot;));&#10;        filteredData.put(&quot;info&quot;, data.get(&quot;info&quot;));&#10;        if (data.containsKey(&quot;servers&quot;)) {&#10;            filteredData.put(&quot;servers&quot;, data.get(&quot;servers&quot;));&#10;        }&#10;        if (data.containsKey(&quot;components&quot;)) {&#10;            filteredData.put(&quot;components&quot;, data.get(&quot;components&quot;));&#10;        }&#10;        filteredData.put(&quot;paths&quot;, newPaths);&#10;&#10;        return filteredData;&#10;    }&#10;&#10;    public String toYaml(Map&lt;String, Object&gt; filteredData) {&#10;        if (filteredData == null) {&#10;            return &quot;&quot;;&#10;        }&#10;        DumperOptions options = new DumperOptions();&#10;        options.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);&#10;        options.setPrettyFlow(true);&#10;        options.setIndent(2);&#10;&#10;        Yaml yaml = new Yaml(options);&#10;        return yaml.dump(filteredData);&#10;    }&#10;&#10;    /**&#10;     * 將過濾後的 YAML 結構寫入指定檔案&#10;     * @param filteredData 過濾後的 YAML 結構&#10;     * @param outputFilePath 輸出檔案路徑&#10;     * @throws IOException 寫檔失敗時拋出&#10;     */&#10;    public void writeFilteredYaml(Map&lt;String, Object&gt; filteredData, String outputFilePath) throws IOException {&#10;        if (filteredData == null) return;&#10;        String yamlStr = toYaml(filteredData);&#10;        try (FileWriter writer = new FileWriter(outputFilePath)) {&#10;            writer.write(yamlStr);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/swagger/src/main/java/com/nicenpc/swagger/SchemaConverter.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/swagger/src/main/java/com/nicenpc/swagger/SchemaConverter.java" />
              <option name="originalContent" value="package com.nicenpc.swagger;&#10;&#10;import com.nicenpc.swagger.model.Payload;&#10;import io.swagger.v3.oas.models.OpenAPI;&#10;import io.swagger.v3.oas.models.media.Schema;&#10;import org.springframework.stereotype.Component;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Map;&#10;&#10;&#10;public class SchemaConverter {&#10;&#10;  private final OpenAPI openAPI;&#10;&#10;  public SchemaConverter(OpenAPI openAPI) {&#10;    this.openAPI = openAPI;&#10;  }&#10;&#10;  public Payload toPayload(Schema schema) {&#10;    if (schema.get$ref() != null) {&#10;      schema = getRefSchema(schema.get$ref());&#10;    }&#10;&#10;    List&lt;Payload.Field&gt; fields = new ArrayList&lt;&gt;();&#10;    for (Map.Entry&lt;String, Schema&gt; entry :&#10;        (Iterable&lt;Map.Entry&lt;String, Schema&gt;&gt;) schema.getProperties().entrySet()) {&#10;      String name = entry.getKey();&#10;      Schema propertySchema = entry.getValue();&#10;&#10;      Payload.Field field =&#10;          Payload.Field.builder()&#10;              .name(name)&#10;              .type(propertySchema.getType())&#10;              .description(propertySchema.getDescription())&#10;              .example(propertySchema.getExample())&#10;              .required(schema.getRequired() != null &amp;&amp; schema.getRequired().contains(name))&#10;              .build();&#10;&#10;      fields.add(field);&#10;    }&#10;&#10;    return Payload.builder().fields(fields).build();&#10;  }&#10;&#10;  private Schema getRefSchema(String ref) {&#10;    String[] parts = ref.split(&quot;/&quot;);&#10;    String schemaName = parts[parts.length - 1];&#10;    return openAPI.getComponents().getSchemas().get(schemaName);&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="package com.nicenpc.swagger;&#10;&#10;import com.nicenpc.swagger.model.Payload;&#10;import io.swagger.v3.oas.models.OpenAPI;&#10;import io.swagger.v3.oas.models.media.Schema;&#10;import org.springframework.stereotype.Component;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Map;&#10;&#10;&#10;public class SchemaConverter {&#10;&#10;  private final OpenAPI openAPI;&#10;&#10;  public SchemaConverter(OpenAPI openAPI) {&#10;    this.openAPI = openAPI;&#10;  }&#10;&#10;  public Payload toPayload(Schema schema) {&#10;    return toPayload(schema, &quot;&quot;, 1);&#10;  }&#10;&#10;  private Payload toPayload(Schema schema, String parentPath, int level) {&#10;    if (schema.get$ref() != null) {&#10;      schema = getRefSchema(schema.get$ref());&#10;    }&#10;&#10;    List&lt;Payload.Field&gt; fields = new ArrayList&lt;&gt;();&#10;    &#10;    if (schema.getProperties() != null) {&#10;      for (Map.Entry&lt;String, Schema&gt; entry :&#10;          (Iterable&lt;Map.Entry&lt;String, Schema&gt;&gt;) schema.getProperties().entrySet()) {&#10;        String name = entry.getKey();&#10;        Schema propertySchema = entry.getValue();&#10;        String currentPath = parentPath.isEmpty() ? name : parentPath + &quot;.&quot; + name;&#10;&#10;        // 處理基本欄位&#10;        Payload.Field field = createField(name, propertySchema, schema, currentPath, level);&#10;        fields.add(field);&#10;&#10;        // 遞歸處理嵌套物件&#10;        if (isObjectType(propertySchema)) {&#10;          Payload nestedPayload = toPayload(propertySchema, currentPath, level + 1);&#10;          fields.addAll(nestedPayload.getFields());&#10;        }&#10;        // 處理數組類型&#10;        else if (&quot;array&quot;.equals(propertySchema.getType()) &amp;&amp; propertySchema.getItems() != null) {&#10;          Schema itemSchema = propertySchema.getItems();&#10;          if (isObjectType(itemSchema)) {&#10;            Payload nestedPayload = toPayload(itemSchema, currentPath, level + 1);&#10;            fields.addAll(nestedPayload.getFields());&#10;          }&#10;        }&#10;      }&#10;    }&#10;&#10;    return Payload.builder().fields(fields).build();&#10;  }&#10;&#10;  private Payload.Field createField(String name, Schema propertySchema, Schema parentSchema, String path, int level) {&#10;    if (propertySchema.get$ref() != null) {&#10;      propertySchema = getRefSchema(propertySchema.get$ref());&#10;    }&#10;&#10;    return Payload.Field.builder()&#10;        .name(name)&#10;        .type(getSchemaType(propertySchema))&#10;        .description(propertySchema.getDescription())&#10;        .example(propertySchema.getExample())&#10;        .required(parentSchema.getRequired() != null &amp;&amp; parentSchema.getRequired().contains(name))&#10;        .path(path)&#10;        .level(level)&#10;        .build();&#10;  }&#10;&#10;  private boolean isObjectType(Schema schema) {&#10;    if (schema.get$ref() != null) {&#10;      return true;&#10;    }&#10;    return &quot;object&quot;.equals(schema.getType()) &amp;&amp; schema.getProperties() != null;&#10;  }&#10;&#10;  private String getSchemaType(Schema schema) {&#10;    if (schema.get$ref() != null) {&#10;      return &quot;object&quot;;&#10;    }&#10;    if (&quot;array&quot;.equals(schema.getType()) &amp;&amp; schema.getItems() != null) {&#10;      return &quot;array[&quot; + getSchemaType(schema.getItems()) + &quot;]&quot;;&#10;    }&#10;    return schema.getType();&#10;  }&#10;&#10;  private Schema getRefSchema(String ref) {&#10;    String[] parts = ref.split(&quot;/&quot;);&#10;    String schemaName = parts[parts.length - 1];&#10;    return openAPI.getComponents().getSchemas().get(schemaName);&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/swagger/src/main/java/com/nicenpc/swagger/YamlFilter.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/swagger/src/main/java/com/nicenpc/swagger/YamlFilter.java" />
              <option name="originalContent" value="package com.nicenpc.swagger;&#10;&#10;import org.yaml.snakeyaml.DumperOptions;&#10;import org.yaml.snakeyaml.LoaderOptions;&#10;import org.yaml.snakeyaml.Yaml;&#10;&#10;import java.io.FileInputStream;&#10;import java.io.FileNotFoundException;&#10;import java.io.InputStream;&#10;import java.util.LinkedHashMap;&#10;import java.util.Map;&#10;&#10;public class YamlFilter {&#10;&#10;    private final Map&lt;String, Object&gt; data;&#10;&#10;    public YamlFilter(String yamlFilePath) throws FileNotFoundException {&#10;        InputStream inputStream = new FileInputStream(yamlFilePath);&#10;        LoaderOptions options = new LoaderOptions();&#10;        options.setCodePointLimit(20 * 1024 * 1024); // 10MB&#10;        Yaml yaml = new Yaml(options);&#10;        this.data = yaml.load(inputStream);&#10;    }&#10;&#10;    public Map&lt;String, Object&gt; filterByApi(String apiPath, String httpMethod) {&#10;        if (data == null || !data.containsKey(&quot;paths&quot;)) {&#10;            return null;&#10;        }&#10;&#10;        Map&lt;String, Object&gt; paths = (Map&lt;String, Object&gt;) data.get(&quot;paths&quot;);&#10;        if (!paths.containsKey(apiPath)) {&#10;            return null;&#10;        }&#10;&#10;        Map&lt;String, Object&gt; pathItem = (Map&lt;String, Object&gt;) paths.get(apiPath);&#10;        String methodKey = httpMethod.toLowerCase();&#10;        if (!pathItem.containsKey(methodKey)) {&#10;            return null;&#10;        }&#10;&#10;        Object operation = pathItem.get(methodKey);&#10;&#10;        // 建立新的過濾後的資料結構&#10;        Map&lt;String, Object&gt; filteredData = new LinkedHashMap&lt;&gt;();&#10;        // 複製 metadata&#10;        filteredData.put(&quot;openapi&quot;, data.get(&quot;openapi&quot;));&#10;        filteredData.put(&quot;info&quot;, data.get(&quot;info&quot;));&#10;        if (data.containsKey(&quot;servers&quot;)) {&#10;            filteredData.put(&quot;servers&quot;, data.get(&quot;servers&quot;));&#10;        }&#10;        if (data.containsKey(&quot;components&quot;)) {&#10;            filteredData.put(&quot;components&quot;, data.get(&quot;components&quot;)); // 為了確保 $ref 能正常運作，保留所有 components&#10;        }&#10;&#10;&#10;        // 建立只包含指定 API 的 paths&#10;        Map&lt;String, Object&gt; newPathItem = new LinkedHashMap&lt;&gt;();&#10;        newPathItem.put(methodKey, operation);&#10;&#10;        Map&lt;String, Object&gt; newPaths = new LinkedHashMap&lt;&gt;();&#10;        newPaths.put(apiPath, newPathItem);&#10;&#10;        filteredData.put(&quot;paths&quot;, newPaths);&#10;&#10;        return filteredData;&#10;    }&#10;&#10;    /**&#10;     * 根據多個 API 路徑與方法過濾，產生新的 YAML 結構&#10;     * @param apiMethods 欲保留的 API 路徑與方法，格式為 Map&lt;apiPath, List&lt;httpMethod&gt;&gt;&#10;     * @return 過濾後的 YAML 結構&#10;     */&#10;    public Map&lt;String, Object&gt; filterByApis(Map&lt;String, java.util.List&lt;String&gt;&gt; apiMethods) {&#10;        if (data == null || !data.containsKey(&quot;paths&quot;)) {&#10;            return null;&#10;        }&#10;&#10;        Map&lt;String, Object&gt; paths = (Map&lt;String, Object&gt;) data.get(&quot;paths&quot;);&#10;        Map&lt;String, Object&gt; newPaths = new LinkedHashMap&lt;&gt;();&#10;&#10;        for (Map.Entry&lt;String, java.util.List&lt;String&gt;&gt; entry : apiMethods.entrySet()) {&#10;            String apiPath = entry.getKey();&#10;            if (!paths.containsKey(apiPath)) continue;&#10;            Map&lt;String, Object&gt; pathItem = (Map&lt;String, Object&gt;) paths.get(apiPath);&#10;&#10;            Map&lt;String, Object&gt; newPathItem = new LinkedHashMap&lt;&gt;();&#10;            for (String method : entry.getValue()) {&#10;                String methodKey = method.toLowerCase();&#10;                if (pathItem.containsKey(methodKey)) {&#10;                    newPathItem.put(methodKey, pathItem.get(methodKey));&#10;                }&#10;            }&#10;            if (!newPathItem.isEmpty()) {&#10;                newPaths.put(apiPath, newPathItem);&#10;            }&#10;        }&#10;&#10;        if (newPaths.isEmpty()) return null;&#10;&#10;        Map&lt;String, Object&gt; filteredData = new LinkedHashMap&lt;&gt;();&#10;        filteredData.put(&quot;openapi&quot;, data.get(&quot;openapi&quot;));&#10;        filteredData.put(&quot;info&quot;, data.get(&quot;info&quot;));&#10;        if (data.containsKey(&quot;servers&quot;)) {&#10;            filteredData.put(&quot;servers&quot;, data.get(&quot;servers&quot;));&#10;        }&#10;        if (data.containsKey(&quot;components&quot;)) {&#10;            filteredData.put(&quot;components&quot;, data.get(&quot;components&quot;));&#10;        }&#10;        filteredData.put(&quot;paths&quot;, newPaths);&#10;&#10;        return filteredData;&#10;    }&#10;&#10;    public String toYaml(Map&lt;String, Object&gt; filteredData) {&#10;        if (filteredData == null) {&#10;            return &quot;&quot;;&#10;        }&#10;        DumperOptions options = new DumperOptions();&#10;        options.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);&#10;        options.setPrettyFlow(true);&#10;        options.setIndent(2);&#10;&#10;        Yaml yaml = new Yaml(options);&#10;        return yaml.dump(filteredData);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.nicenpc.swagger;&#10;&#10;import org.yaml.snakeyaml.DumperOptions;&#10;import org.yaml.snakeyaml.LoaderOptions;&#10;import org.yaml.snakeyaml.Yaml;&#10;&#10;import java.io.FileInputStream;&#10;import java.io.FileNotFoundException;&#10;import java.io.FileWriter;&#10;import java.io.IOException;&#10;import java.io.InputStream;&#10;import java.util.LinkedHashMap;&#10;import java.util.Map;&#10;&#10;public class YamlFilter {&#10;&#10;    private final Map&lt;String, Object&gt; data;&#10;&#10;    public YamlFilter(String yamlFilePath) throws FileNotFoundException {&#10;        InputStream inputStream = new FileInputStream(yamlFilePath);&#10;        LoaderOptions options = new LoaderOptions();&#10;        options.setCodePointLimit(20 * 1024 * 1024); // 10MB&#10;        Yaml yaml = new Yaml(options);&#10;        this.data = yaml.load(inputStream);&#10;    }&#10;&#10;    public Map&lt;String, Object&gt; filterByApi(String apiPath, String httpMethod) {&#10;        if (data == null || !data.containsKey(&quot;paths&quot;)) {&#10;            return null;&#10;        }&#10;&#10;        Map&lt;String, Object&gt; paths = (Map&lt;String, Object&gt;) data.get(&quot;paths&quot;);&#10;        if (!paths.containsKey(apiPath)) {&#10;            return null;&#10;        }&#10;&#10;        Map&lt;String, Object&gt; pathItem = (Map&lt;String, Object&gt;) paths.get(apiPath);&#10;        String methodKey = httpMethod.toLowerCase();&#10;        if (!pathItem.containsKey(methodKey)) {&#10;            return null;&#10;        }&#10;&#10;        Object operation = pathItem.get(methodKey);&#10;&#10;        // 建立新的過濾後的資料結構&#10;        Map&lt;String, Object&gt; filteredData = new LinkedHashMap&lt;&gt;();&#10;        // 複製 metadata&#10;        filteredData.put(&quot;openapi&quot;, data.get(&quot;openapi&quot;));&#10;        filteredData.put(&quot;info&quot;, data.get(&quot;info&quot;));&#10;        if (data.containsKey(&quot;servers&quot;)) {&#10;            filteredData.put(&quot;servers&quot;, data.get(&quot;servers&quot;));&#10;        }&#10;        if (data.containsKey(&quot;components&quot;)) {&#10;            filteredData.put(&quot;components&quot;, data.get(&quot;components&quot;)); // 為了確保 $ref 能正常運作，保留所有 components&#10;        }&#10;&#10;&#10;        // 建立只包含指定 API 的 paths&#10;        Map&lt;String, Object&gt; newPathItem = new LinkedHashMap&lt;&gt;();&#10;        newPathItem.put(methodKey, operation);&#10;&#10;        Map&lt;String, Object&gt; newPaths = new LinkedHashMap&lt;&gt;();&#10;        newPaths.put(apiPath, newPathItem);&#10;&#10;        filteredData.put(&quot;paths&quot;, newPaths);&#10;&#10;        return filteredData;&#10;    }&#10;&#10;    /**&#10;     * 根據多個 API 路徑與方法過濾，產生新的 YAML 結構&#10;     * @param apiMethods 欲保留的 API 路徑與方法，格式為 Map&lt;apiPath, List&lt;httpMethod&gt;&gt;&#10;     * @return 過濾後的 YAML 結構&#10;     */&#10;    public Map&lt;String, Object&gt; filterByApis(Map&lt;String, java.util.List&lt;String&gt;&gt; apiMethods) {&#10;        if (data == null || !data.containsKey(&quot;paths&quot;)) {&#10;            return null;&#10;        }&#10;&#10;        Map&lt;String, Object&gt; paths = (Map&lt;String, Object&gt;) data.get(&quot;paths&quot;);&#10;        Map&lt;String, Object&gt; newPaths = new LinkedHashMap&lt;&gt;();&#10;&#10;        for (Map.Entry&lt;String, java.util.List&lt;String&gt;&gt; entry : apiMethods.entrySet()) {&#10;            String apiPath = entry.getKey();&#10;            if (!paths.containsKey(apiPath)) continue;&#10;            Map&lt;String, Object&gt; pathItem = (Map&lt;String, Object&gt;) paths.get(apiPath);&#10;&#10;            Map&lt;String, Object&gt; newPathItem = new LinkedHashMap&lt;&gt;();&#10;            for (String method : entry.getValue()) {&#10;                String methodKey = method.toLowerCase();&#10;                if (pathItem.containsKey(methodKey)) {&#10;                    newPathItem.put(methodKey, pathItem.get(methodKey));&#10;                }&#10;            }&#10;            if (!newPathItem.isEmpty()) {&#10;                newPaths.put(apiPath, newPathItem);&#10;            }&#10;        }&#10;&#10;        if (newPaths.isEmpty()) return null;&#10;&#10;        Map&lt;String, Object&gt; filteredData = new LinkedHashMap&lt;&gt;();&#10;        filteredData.put(&quot;openapi&quot;, data.get(&quot;openapi&quot;));&#10;        filteredData.put(&quot;info&quot;, data.get(&quot;info&quot;));&#10;        if (data.containsKey(&quot;servers&quot;)) {&#10;            filteredData.put(&quot;servers&quot;, data.get(&quot;servers&quot;));&#10;        }&#10;        if (data.containsKey(&quot;components&quot;)) {&#10;            filteredData.put(&quot;components&quot;, data.get(&quot;components&quot;));&#10;        }&#10;        filteredData.put(&quot;paths&quot;, newPaths);&#10;&#10;        return filteredData;&#10;    }&#10;&#10;    public String toYaml(Map&lt;String, Object&gt; filteredData) {&#10;        if (filteredData == null) {&#10;            return &quot;&quot;;&#10;        }&#10;        DumperOptions options = new DumperOptions();&#10;        options.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);&#10;        options.setPrettyFlow(true);&#10;        options.setIndent(2);&#10;&#10;        Yaml yaml = new Yaml(options);&#10;        return yaml.dump(filteredData);&#10;    }&#10;&#10;    /**&#10;     * 將過濾後的 YAML 結構寫入指定檔案&#10;     * @param filteredData 過濾後的 YAML 結構&#10;     * @param outputFilePath 輸出檔案路徑&#10;     * @throws IOException 寫檔失敗時拋出&#10;     */&#10;    public void writeFilteredYaml(Map&lt;String, Object&gt; filteredData, String outputFilePath) throws IOException {&#10;        if (filteredData == null) return;&#10;        String yamlStr = toYaml(filteredData);&#10;        try (FileWriter writer = new FileWriter(outputFilePath)) {&#10;            writer.write(yamlStr);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>